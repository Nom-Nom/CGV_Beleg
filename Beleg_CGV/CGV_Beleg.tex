\documentclass[a4paper,11pt]{scrartcl}

\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{import}

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{
  frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\lstset{literate=%
  {Ö}{{\"O}}1
  {Ä}{{\"A}}1
  {Ü}{{\"U}}1
  {ß}{{\ss}}1
  {ü}{{\"u}}1
  {ä}{{\"a}}1
  {ö}{{\"o}}1
}

\title{Beleg Computergrafik und Visualisierung II - Teil I}
\author{Wiebke Rochler, Christopher Praas, Anna Krauß}

\begin{document}

\maketitle
\tableofcontents
\newpage
\section{Einleitung}
Dies ist die Dokumentation zum Quellcode für das den Beleg im Fach Computergrafik und Visualisierung II bei Prof. Dr. Marco Block-Berlitz. Im ersten Teil des Belegs war es Aufgabe drei Klassen in Java zu implementieren. Bei der Umsetzung war darauf zu achten, dass Methoden erstellt werden, die in der Lage sind mögliche Fehler aufspüren und entsprechend zu reagieren.
Die verschiedenen Klassen samt Methoden wurden in einem Package realisiert. In einem zweiten Package sind alle Tests zu den jeweiligen Methoden implementiert.
\newpage
\section{Erläuterung der verwendeten Klassen}
\subsection{Vektor2D}
Die Klasse Vektor2D repräsentiert 2D-Vektoren. Die Koordinaten werden jeweils durch double-Werte dargestellt. Zunächst besitzt die Klasse drei verschiedene Konstruktoren, durch die es möglich ist auf verschiedene Art und Weisen Objekte der Klasse Vektor2D zu erstellen. Des Weiteren beinhaltet die Klasse die Grundrechenarten Addition, Subtraktion, Multiplikation und Division. Darüber hinaus werden Methoden angeboten, mithilfe derer Vektoren verglichen, normiert und an eine bestimmte Position gesetzt werden können. Außerdem kann die Vektorlänge berechnet und geprüft werden ob es sich um einen Nullvektor handelt. Alle Methoden wurden testgetrieben entwickelt, weshalb sie bestimmte Fehler erkennen und behandeln können. Wenn ein solcher Fehlerfall eintritt, wird eine Exception geworfen um dies kenntlich zu machen. Im Folgenden wird auf die einzelnen Operationen und die eventuell auftretenden Fehler eingegangen.

\subsubsection{Methoden}
\textbf{Addition:}  Bei der Addition bestünde die Möglichkeit, dass es bei zu großen bzw. zu kleinen Zahlen zu einem Überlauf im positiven oder negativen Bereich kommen könnte. Dies lässt sich durch folgende Überlegungen ermitteln:
\begin{lstlisting}
public void add(Vektor2D b) throws Exception
	{
		if((x<0 && b.x<0) || (x>0 && b.x>0) || (y<0 && b.y<0) || (y>0 && b.y>0)) 
			if((Math.abs(x)+Math.abs(b.x) >= Double.MAX_VALUE) || (Math.abs(y)+Math.abs(b.y) >= Double.MAX_VALUE))
				throw new Exception("Ueberlauf! Bitte den maximalen Wertebereich beachten!");
\end{lstlisting}
Es wird also getestet ob die Koordinaten des aufrufenden und des übergebenen Vektors beide größer oder kleiner Null sind. Wenn das der Fall ist, wird aus diesen der Betrag gebildet und dann geprüft ob deren Addition größer/gleich dem maximalen Wert des darstellbaren Bereichs ist. Ist dies der Fall, wird eine Exception geworfen und der Nutzer über den Fehler informiert.
(Mit der Bildung des Betrags der Koordinaten genügt der Test auf den Maximalwert von Double.)
\begin{lstlisting}		
		if((x>0 && b.x<0) || (x<0 && b.x>0) || (y>0 && b.y<0) || (y<0 && b.y>0))
			if((Math.abs(x)-Math.abs(b.x) >= Double.MAX_VALUE) || (Math.abs(y)-Math.abs(b.y) >= Double.MAX_VALUE))
				throw new Exception("Ueberlauf! Bitte den maximalen Wertebereich beachten!");
	}
\end{lstlisting}
Des Weiteren bestünde die Möglichkeit einen sehr großen und einen kleinen Wert zu addieren, was ebenfalls zu einem Überlauf führen könnte. Daher wird getestet ob die einzelnen Koordinaten des aufrufenden und des übergebenen Vektoren größer und/oder kleiner Null sind. Wenn das der Fall ist, wird aus diesen der Betrag gebildet und dann geprüft ob deren Subtraktion größer/gleich dem maximalen Wert des darstellbaren Bereichs ist. Ist dies der Fall, wird eine Exception geworfen und der Nutzer über den Fehler informiert.\\
\\
\textbf{Subtraktion:} Prinzipiell können hier die gleichen Fehler auftreten wie bei der Addition. Es muss lediglich bei der Prüfung auf die Vorzeichen geachtet werden. Aufgrund des Bildens der Beträge in der Überprüfung auf Überlauf von der Addition können wir die gleiche Überprüfung auch für die Subtraktion verwenden.\\
\\
\textbf{Multiplikation:} Bei der Multiplikation wird ein Vektor mit einer Doublezahl multipliziert. Dabei sollte auch dort darauf geachtet werden, dass kein Überlauf zustande kommt. Das verhindern wir, indem wir auch hier darauf testen ob die Operation einen größeren Wert erzeugen würde, als durch Double darstellbar. Auch hier werfen wir im Fehlerfall eine Exception und geben eine Fehlermeldung zurück.\\
\textit{Programmcode zur Verdeutlichung:}
\begin{lstlisting}
public void mult(double b) throws Exception
	{
		if((Math.abs(x)*Math.abs(b) >= Double.MAX_VALUE) || (Math.abs(y)+Math.abs(b) >= Double.MAX_VALUE))
			throw new Exception("Ueberlauf! Bitte den maximalen Wertebereich beachten!");
		x*=b;
		y*=b;
	}
\end{lstlisting} $\;$ \\
\textbf{Division:} Bei der Division muss abgesehen von dem Test auf positiven und negativen Überlauf auch getestet werden, ob der Divisor Null ist, da Division durch Null nicht zulässig ist. Wurde dies durch den Nutzer nicht beachtet, wird eine Exception geworfen und darauf hingewiesen.
Für den Test auf Überlauf muss überprüft werden ob der Divisor zwischen Null und Eins liegt, da das Ergebnis in dem Fall dann größer ist als der Dividend bzw. im Falle b==1 gleich groß. Also wird auch hier der Betrag der Koordinaten gebildet und die Division auf Überlauf getestet. Im Fehlerfall erfolgt auch hier eine Exception.
\textit{Programmcode zur Verdeutlichung:}
\begin{lstlisting}
	public void div(double b) throws Exception
	{
		if(b==0)
			throw new Exception("Division durch 0 ist nicht zulässig!");
		
		if((b<1 && b > 0) || b==1)
			if((Math.abs(x)/Math.abs(b) >= Double.MAX_VALUE) || (Math.abs(y)/Math.abs(b) >= Double.MAX_VALUE))
				throw new Exception("Ueberlauf! Bitte den maximalen Wertebereich beachten!");
		
		x/=b;
		y/=b;
	}
\end{lstlisting} $\;$ \\
\textbf{setPosition(): } Diese Funktion bietet die Möglichkeit einem Vektor durch Übergabe von x- und y-Koordinate eine neue Position zuzuweisen. Eventuell könnten diese übergebenen Werte größer sein als der double-Maximalwert, was wir durch vorheriges Prüfen ausgeschlossen haben.\\
\textit{Programmcode zur Verdeutlichung:}
\begin{lstlisting}
	public void setPosition(double x1, double y1) throws Exception
	{
		if((Math.abs(x1)>=Double.MAX_VALUE) || (Math.abs(y1)>=Double.MAX_VALUE))
			throw new Exception("Ueberlauf! Bitte den maximalen Wertebereich beachten!");
		
		x=x1;
		y=y1;
	}
\end{lstlisting} $\;$ \\
\textbf{isNullVector(): } In der Methode wird überprüft, ob der aufrufende Vektor ein Nullvektor ist. Dabei war nur die Korrektheit der Funktion zu prüfen.\\
\\
\textbf{isEqual(): } In isEqual() wird überprüft, ob der aufrufende und der übergebene Vektor den gleichen Inhalt haben. Dabei war nur die Korrektheit der Funktion zu prüfen. (Vergleich Inhalt und nicht die Objektreferenzen)\\
\\
\textbf{isNotEqual(): } Hierbei handelt es sich um die Umkehrfunktion von isEqual(), bei welcher wir gleichermaßen vorgegangen sind.\\
\\
\textbf{length(): } Die Methode length() berechnet die Länge des aufrufenden Vektors.\\
Mathematische Bildungsvorschrift für die Länge eines Vektors der Dimension Zwei:
\[ ||\vec v|| = \sqrt{x^2 + y^2} \]
Hier war darauf zu achten, dass das Quadrat der x- und y-Koordinaten keinen Überlauf verursacht, was durch eine Abfrage und im Fehlerfall geworfene Exception vermieden wird.\\
\\
\textbf{normalize(): } Auch bei der Normierung des aufrufenden Vektors wird das Quadrat der x- und y-Koordinaten auf vermeintlichen Überlauf geprüft, was durch eine Abfrage und im Fehlerfall geworfene Exception vermieden wird.\\
Die Normierung wird erreicht, indem der Vektor durch seine Länge geteilt wird:
\[ \frac{1}{||\vec v||} \cdot \vec v \]
Hier bietet es sich an die bereits vorhandenen Funktionenen mult() und length() aufzurufen.\\
\\
\textit{Programmcode zur Verdeutlichung:}
\begin{lstlisting}
	public void normalize() throws Exception
	{
		if(((x*x) >= Double.MAX_VALUE) || ((y*y) >= Double.MAX_VALUE))
		{
			throw new Exception("Ueberlauf! Bitte den maximalen Wertebereich beachten!");
		}
		mult(1/length());
		// double tmplaenge=Math.sqrt((x*x)+(y*y)); 		
		// div(tmplaenge);
	}
\end{lstlisting}

\subsection{Vektor3D}
Die Klasse Vektor3D repräsentiert 3D-Vektoren. Der einzige Unterschied zur Klasse Vektor2D liegt bei der Erweiterung um die z-Koordinate. Die Koordinaten werden jeweils durch double-Werte dargestellt. Zunächst besitzt die Klasse drei verschiedene Konstruktoren, durch die es möglich ist auf verschiedene Art und Weisen Objekte der Klasse Vektor3D zu erstellen. Des Weiteren beinhaltet die Klasse die Grundrechenarten Addition, Subtraktion, Multiplikation und Division. Darüber hinaus werden Methoden angeboten, mithilfe derer Vektoren verglichen, normiert und an eine bestimmte Position gesetzt werden können. Außerdem kann die Vektorlänge berechnet und geprüft werden ob es sich um einen Nullvektor handelt. Alle Methoden wurden testgetrieben entwickelt, weshalb sie bestimmte Fehler erkennen und behandeln können. Wenn ein solcher Fehlerfall eintritt, wird eine Exception geworfen um dies kenntlich zu machen. Im Folgenden wird auf die einzelnen Operationen und die eventuell auftretenden Fehler eingegangen.
\subsubsection{Methoden}
\textbf{Addition:}  Bei der Addition bestünde die Möglichkeit, dass es bei zu großen bzw. zu kleinen Zahlen zu einem Überlauf im positiven oder negativen Bereich kommen könnte. Dies lässt sich durch folgende Überlegungen ermitteln:
\begin{lstlisting}
	public void add(Vektor3D b) throws Exception
	{
		if((x<0 && b.x<0) || (x>0 && b.x>0) || (y<0 && b.y<0) || (y>0 && b.y>0) || (z<0 && b.z<0) || (z>0 && b.z>0))
			if((Math.abs(x)+Math.abs(b.x) >= Double.MAX_VALUE) || (Math.abs(y)+Math.abs(b.y) >= Double.MAX_VALUE) || (Math.abs(z)+Math.abs(b.z) >= Double.MAX_VALUE))
				throw new Exception("Ueberlauf! Bitte den maximalen Wertebereich beachten!");
\end{lstlisting}
Es wird also getestet ob die Koordinaten des aufrufenden und des übergebenen Vektors beide größer oder kleiner Null sind. Wenn das der Fall ist, wird aus diesen der Betrag gebildet und dann geprüft ob deren Addition größer/gleich dem maximalen Wert des darstellbaren Bereichs ist. Ist dies der Fall, wird eine Exception geworfen und der Nutzer über den Fehler informiert.
(Mit der Bildung des Betrags der Koordinaten genügt der Test auf den Maximalwert von Double.)
\begin{lstlisting}		
		if((x>0 && b.x<0) || (x<0 && b.x>0) || (y>0 && b.y<0) || (y<0 && b.y>0) || (z>0 && b.z<0) || (z<0 && b.z>0))
			if((Math.abs(x)-Math.abs(b.x) >= Double.MAX_VALUE) || (Math.abs(y)-Math.abs(b.y) >= Double.MAX_VALUE) || (Math.abs(z)-Math.abs(b.z) >= Double.MAX_VALUE))
				throw new Exception("Ueberlauf! Bitte den maximalen Wertebereich beachten!");
		x+=b.x;
		y+=b.y;
		z+=b.z;
	}
\end{lstlisting}
Des Weiteren bestünde die Möglichkeit einen sehr großen und einen kleinen Wert zu addieren, was ebenfalls zu einem Überlauf führen könnte. Daher wird getestet ob die einzelnen Koordinaten des aufrufenden und des übergebenen Vektoren größer und/oder kleiner Null sind. Wenn das der Fall ist, wird aus diesen der Betrag gebildet und dann geprüft ob deren Subtraktion größer/gleich dem maximalen Wert des darstellbaren Bereichs ist. Ist dies der Fall, wird eine Exception geworfen und der Nutzer über den Fehler informiert.\\
\\
\textbf{Subtraktion:} Prinzipiell können hier die gleichen Fehler auftreten wie bei der Addition. Es muss lediglich bei der Prüfung auf die Vorzeichen geachtet werden. Aufgrund des Bildens der Beträge in der Überprüfung auf Überlauf von der Addition können wir die gleiche Überprüfung auch für die Subtraktion verwenden.\\
\\
\textbf{Multiplikation:} Bei der Multiplikation wird ein Vektor mit einer Doublezahl multipliziert. Dabei sollte auch dort darauf geachtet werden, dass kein Überlauf zustande kommt. Das verhindern wir, indem wir auch hier darauf testen ob die Operation einen größeren Wert erzeugen würde, als durch Double darstellbar. Auch hier werfen wir im Fehlerfall eine Exception und geben eine Fehlermeldung zurück.\\
\textit{Programmcode zur Verdeutlichung:}
\begin{lstlisting}
	public void mult(double b) throws Exception
	{
		if((Math.abs(x)*Math.abs(b) >= Double.MAX_VALUE) || (Math.abs(y)+Math.abs(b) >= Double.MAX_VALUE) || (Math.abs(z)+Math.abs(b) >= Double.MAX_VALUE))
			throw new Exception("Ueberlauf! Bitte den maximalen Wertebereich beachten!");
		x*=b;
		y*=b;
		z*=b;
	}
\end{lstlisting} $\;$ \\
\textbf{Division:} Bei der Division muss abgesehen von dem Test auf positiven und negativen Überlauf auch getestet werden, ob der Divisor Null ist, da Division durch Null nicht zulässig ist. Wurde dies durch den Nutzer nicht beachtet, wird eine Exception geworfen und darauf hingewiesen.
Für den Test auf Überlauf muss überprüft werden ob der Divisor zwischen Null und Eins liegt, da das Ergebnis in dem Fall dann größer ist als der Dividend bzw. im Falle b==1 gleich groß. Also wird auch hier der Betrag der Koordinaten gebildet und die Division auf Überlauf getestet. Im Fehlerfall erfolgt auch hier eine Exception.
\textit{Programmcode zur Verdeutlichung:}
\begin{lstlisting}
	public void div(double b) throws Exception
	{
		if(b==0)
			throw new Exception("Division durch 0 ist nicht zulässig!");
		
		if((b<1 && b > 0) || b==1)
			if((Math.abs(x)/Math.abs(b) >= Double.MAX_VALUE) || (Math.abs(y)/Math.abs(b) >= Double.MAX_VALUE) || (Math.abs(z)/Math.abs(b) >= Double.MAX_VALUE))
				throw new Exception("Ueberlauf! Bitte den maximalen Wertebereich beachten!");
		
		x/=b;
		y/=b;
		z/=b;
	}
\end{lstlisting} $\;$ \\
\textbf{setPosition(): } Diese Funktion bietet die Möglichkeit einem Vektor durch Übergabe von x-, y- und z-Koordinate eine neue Position zuzuweisen. Eventuell könnten diese übergebenen Werte größer sein als der double-Maximalwert, was wir durch vorheriges Prüfen ausgeschlossen haben.\\
\textit{Programmcode zur Verdeutlichung:}
\begin{lstlisting}
	public void setPosition(double x1, double y1, double z1) throws Exception
	{
		if((Math.abs(x1)>=Double.MAX_VALUE) || (Math.abs(y1)>=Double.MAX_VALUE) || (Math.abs(z1)>=Double.MAX_VALUE))
			throw new Exception("Ueberlauf! Bitte den maximalen Wertebereich beachten!");
		x=x1;
		y=y1;
		z=z1;
	}
\end{lstlisting} $\;$ \\
\textbf{isNullVector(): } In der Methode wird überprüft, ob der aufrufende Vektor ein Nullvektor ist. Dabei war nur die Korrektheit der Funktion zu prüfen.\\
\\
\textbf{isEqual(): } In isEqual() wird überprüft, ob der aufrufende und der übergebene Vektor den gleichen Inhalt haben. Dabei war nur die Korrektheit der Funktion zu prüfen. (Vergleich Inhalt und nicht die Objektreferenzen)\\
\\
\textbf{isNotEqual(): } Hierbei handelt es sich um die Umkehrfunktion von isEqual(), bei welcher wir gleichermaßen vorgegangen sind.\\
\\
\textbf{length(): } Die Methode length() berechnet die Länge des aufrufenden Vektors.\\
Mathematische Bildungsvorschrift für die Länge eines Vektors der Dimension Drei:
\[ ||\vec v|| = \sqrt{x^2 + y^2 + z^2} \]
Hier war darauf zu achten, dass das Quadrat der x-, y- und z-Koordinaten keinen Überlauf verursacht, was durch eine Abfrage und im Fehlerfall geworfene Exception vermieden wird.\\
\\
\textbf{normalize(): } Auch bei der Normierung des aufrufenden Vektors wird das Quadrat der x-, y- und z-Koordinaten auf vermeintlichen Überlauf geprüft, was durch eine Abfrage und im Fehlerfall geworfene Exception vermieden wird.\\
Die Normierung wird erreicht, indem der Vektor durch seine Länge geteilt wird:
\[ \frac{1}{||\vec v||} \cdot \vec v \]
Hier bietet es sich an die bereits vorhandenen Funktionenen mult() und length() aufzurufen.\\
\textit{Programmcode zur Verdeutlichung:}
\begin{lstlisting}
	public void normalize() throws Exception
	{
		if(((x*x) >= Double.MAX_VALUE) || ((y*y) >= Double.MAX_VALUE) || ((z*z) >= Double.MAX_VALUE))
		{
			throw new Exception("Ueberlauf! Bitte den maximalen Wertebereich beachten!");
		}
		mult(1/length());
		// double tmplaenge=Math.sqrt((x*x)+(y*y)+(z*z));		
		// div(tmplaenge);
	}
\end{lstlisting}
\subsection{LineareAlgebra}
Die Klasse LineareAlgebra stellt verschiedene Methoden für 2D- und 3D-Vektoren bereit. Da diese Methoden alle statisch sind, wird ein privater Konstruktor benötigt um sicher zu stellen, dass kein Objekt von LineareAlgebra angelegt wird. 
\begin{lstlisting}
private LineareAlgebra(){}
\end{lstlisting}
Die verschiedenen Funktionen werden im folgenden näher erläutert.
Bei den Grundrechenarten Addition, Subtraktion, Multiplikation und Division wurde zur Berechnung des Ergebnisses ein temporärer Vektor erstellt.
\subsubsection{Methoden}
\textbf{Addition mit Rückgabetyp Vektor2D:}  Bei der Addition bestünde die Möglichkeit, dass es bei zu großen bzw. zu kleinen Zahlen zu einem Überlauf im positiven oder negativen Bereich kommen könnte. Dies lässt sich durch folgende Überlegungen ermitteln:
\begin{lstlisting}
		public static Vektor2D add(Vektor2D a, Vektor2D b) throws Exception
	{
		if((a.x<0 && b.x<0) || (a.x>0 && b.x>0) || (a.y<0 && b.y<0) || (a.y>0 && b.y>0))
			if((Math.abs(a.x)+Math.abs(b.x) >= Double.MAX_VALUE) || (Math.abs(a.y)+Math.abs(b.y) >= Double.MAX_VALUE))
				throw new Exception("Ueberlauf! Bitte den maximalen Wertebereich beachten!");

\end{lstlisting}
Es wird also getestet ob die Koordinaten der übergebenen Vektoren beide größer oder kleiner Null sind. Wenn das der Fall ist, wird aus diesen der Betrag gebildet und dann geprüft ob deren Addition größer/gleich dem maximalen Wert des darstellbaren Bereichs ist. Ist dies der Fall, wird eine Exception geworfen und der Nutzer über den Fehler informiert.
(Mit der Bildung des Betrags der Koordinaten genügt der Test auf den Maximalwert von Double.)
\begin{lstlisting}		
		if((a.x>0 && b.x<0) || (a.x<0 && b.x>0) || (a.y>0 && b.y<0) || (a.y<0 && b.y>0)) //beide unterschiedlich
			if((Math.abs(a.x)-Math.abs(b.x) >= Double.MAX_VALUE) || (Math.abs(a.y)-Math.abs(b.y) >= Double.MAX_VALUE))
				throw new Exception("Ueberlauf! Bitte den maximalen Wertebereich beachten!");
		
		Vektor2D c = new Vektor2D(a.x+b.x,a.y+b.y);
		return c;
	}
\end{lstlisting}
Des Weiteren bestünde die Möglichkeit einen sehr großen und einen kleinen Wert zu addieren, was ebenfalls zu einem Überlauf führen könnte. Daher wird getestet ob die einzelnen Koordinaten der übergebenen Vektoren größer und/oder kleiner Null sind. Wenn das der Fall ist, wird aus diesen der Betrag gebildet und dann geprüft ob deren Subtraktion größer/gleich dem maximalen Wert des darstellbaren Bereichs ist. Ist dies der Fall, wird eine Exception geworfen und der Nutzer über den Fehler informiert.\\
\\
\textbf{Addition mit Rückgabewert Vektor3D:} Der Unterschied zur vorhergehenden Funktion besteht darin, dass der Rückgabetyp Vektor3D ist und die Abfrage auf Überlauf um die z-Koordinaten erweitert wurde.\\
\\
\textbf{Subtraktion mit Rückgabetyp Vektor2D:} Prinzipiell können hier die gleichen Fehler auftreten wie bei der Addition. Es muss lediglich bei der Prüfung auf die Vorzeichen geachtet werden. Aufgrund des Bildens der Beträge in der Überprüfung auf Überlauf von der Addition können wir die gleiche Überprüfung auch für die Subtraktion verwenden.\\
\\
\textbf{Subtraktion mit Rückgabetyp Vektor3D:} Der Unterschied zur vorhergehenden Funktion besteht darin, dass der Rückgabetyp Vektor3D ist und die Abfrage auf Überlauf um die z-Koordinaten erweitert wurde.\\
\\
\textbf{Multiplikation mit Rückgabteyp Vektor2D:} Bei der Multiplikation wird ein Vektor mit einer Doublezahl multipliziert. Dabei sollte auch dort darauf geachtet werden, dass kein Überlauf zustande kommt. Das verhindern wir, indem wir auch hier darauf testen ob die Operation einen größeren Wert erzeugen würde, als durch Double darstellbar. Auch hier werfen wir im Fehlerfall eine Exception und geben eine Fehlermeldung zurück.\\
\textit{Programmcode zur Verdeutlichung:}
\begin{lstlisting}
	public static Vektor2D mult(Vektor2D a, double b) throws Exception
	{
		if((Math.abs(a.x)*Math.abs(b) >= Double.MAX_VALUE) || (Math.abs(a.y)+Math.abs(b) >= Double.MAX_VALUE))
			throw new Exception("Ueberlauf! Bitte den maximalen Wertebereich beachten!");
		
		Vektor2D c= new Vektor2D();
		c.x=a.x*b;
		c.y=a.y*b;
		return c;
	}
\end{lstlisting} $\;$ \\
\\
\textbf{Multiplikation mit Rückgabetyp Vektor3D:} Der Unterschied zur vorhergehenden Funktion besteht darin, dass der Rückgabetyp Vektor3D ist und die Abfrage auf Überlauf um die z-Koordinaten erweitert wurde.\\
\\
\textbf{Division mit Rückgabetyp Vektor2D:} Da die Division nichts anderes ist als die Umkehrfunktion der Multiplikation, können wir diese hier ganz einfach mit dem Reziproke aufrufen. Es muss abgesehen von dem Test auf positiven und negativen Überlauf auch getestet werden, ob der Divisor Null ist, da Division durch Null nicht zulässig ist. Wurde dies durch den Nutzer nicht beachtet, wird eine Exception geworfen und darauf hingewiesen.
Für den Test auf Überlauf muss überprüft werden ob der Divisor zwischen Null und Eins liegt, da das Ergebnis in dem Fall dann größer ist als der Dividend bzw. im Falle b==1 gleich groß. Also wird auch hier der Betrag der Koordinaten gebildet und die Division auf Überlauf getestet. Im Fehlerfall erfolgt auch hier eine Exception.
\textit{Programmcode zur Verdeutlichung:}
\begin{lstlisting}
	public static Vektor2D div(Vektor2D a, double b) throws Exception
	{
		if(b==0)
			throw new Exception("Division durch 0 ist nicht zulässig!");
		
		if((b<1 && b > 0) || b==1)
			if((Math.abs(a.x)/Math.abs(b) >= Double.MAX_VALUE) || (Math.abs(a.y)/Math.abs(b) >= Double.MAX_VALUE))
				throw new Exception("Ueberlauf! Bitte den maximalen Wertebereich beachten!");
		
		return (mult(a, 1/b));
	}
\end{lstlisting} $\;$ \\
\\
\textbf{Division mit Rückgabetyp Vektor3D:} Der Unterschied zur vorhergehenden Funktion besteht darin, dass der Rückgabetyp Vektor3D ist und die Abfrage auf Überlauf um die z-Koordinaten erweitert wurde.\\
\\
\textbf{isEqual()mit zwei übergebenen Vektor2D- oder zwei Vektor3D-Objekten: } In den Funktionen isEqual() wird überprüft, ob die übergebenen Vektoren den gleichen Inhalt haben. Dabei war nur die Korrektheit der Funktion zu prüfen. (Vergleich Inhalt und nicht die Objektreferenzen)\\
\\
\textbf{isNotEqual()mit zwei übergebenen Vektor2D- oder zwei Vektor3D-Objekten: } Hierbei handelt es sich um die Umkehrfunktionen von isEqual(), bei welcher wir gleichermaßen vorgegangen sind.\\
\\
\textbf{length() von Vektor2D oder Vektor3D: } Die Methoden length() berechnen die Länge des jeweils übergebenen Vektors.\\
Hier war darauf zu achten, dass das Quadrat der x-, y- und (im Falle von length() für Vektor3D) z-Koordinaten keinen Überlauf verursacht, was durch eine Abfrage und im Fehlerfall geworfene Exception vermieden wird.\\
\\
\textbf{normalize() mit Rückgabetyp Vektor2D: } Auch bei der Normierung des übergebenen Vektors wird das Quadrat der x-, y- Koordinate auf vermeintlichen Überlauf geprüft, was durch eine Abfrage und im Fehlerfall geworfene Exception vermieden wird.\\
Die Normierung wird erreicht, indem der Vektor durch seine Länge geteilt wird:
\[ \frac{1}{||\vec v||} \cdot \vec v \]
Hier bietet es sich an die bereits vorhandenen Funktionenen mult() und length() aufzurufen.\\
\textit{Programmcode zur Verdeutlichung:}
\begin{lstlisting}
	public static Vektor2D normalize(Vektor2D a) throws Exception
	{
		if(((a.x*a.x) >= Double.MAX_VALUE) || ((a.y*a.y) >= Double.MAX_VALUE))
			throw new Exception("Ueberlauf! Bitte den maximalen Wertebereich beachten!");
		
		 return (mult(a, 1/length(a)));
	}
\end{lstlisting} $\;$ \\
\\
\textbf{normalize() mit Rückgabetyp Vektor3D:} Der Unterschied zur vorhergehenden Funktion besteht darin, dass der Rückgabetyp Vektor3D ist und die Abfrage auf Überlauf um die z-Koordinaten erweitert wurde.\\
\\
\textbf{euklDistance() mit zwei übergebenen Vektor2D-Objekten:} Die euklidische Distanz für zwei 2D-Vektoren bezeichnet den Abstand dieser in der Ebene. Die Funktion wurde auf Basis von folgender mathematischen Formel programmiert:
\[ euklDistance(p_1,p_2) = \sqrt{(p_2.x - p_1.x)^2 + (p_2.y - p_1.y)^2} \]
Dabei war darauf zu achten, dass die Differenz der beiden Vektorkoordinaten im Quadrat auf vermeintlichen Überlauf geprüft wird und dies im Fehlerfall mit einer Exception behandelt wird.
\begin{lstlisting}
	public static double euklDistance(Vektor2D a, Vektor2D b) throws Exception
	{
		if((Math.pow(a.x-b.x,2)>=Double.MAX_VALUE) || (Math.pow(a.y-b.y,2)>=Double.MAX_VALUE) || (Math.sqrt(Math.pow(a.x-b.x,2)+Math.pow(a.y-b.y,2))>=Double.MAX_VALUE))
			throw new Exception("Ueberlauf! Bitte den maximalen Wertebereich beachten!");
		
		double diffX=Math.pow(a.x-b.x,2);
		double diffY=Math.pow(a.y-b.y,2);
		double dist=Math.sqrt(diffX+diffY);
		return dist;
	}
\end{lstlisting} $\;$ \\
\textbf{euklDistance() mit zwei übergebenen Vektor3D-Objekten:} Die euklidische Distanz für zwei 3D-Vektoren bezeichnet den Abstand dieser im Raum. Die Funktion wurde auf Basis von folgender mathematischen Formel programmiert:
\[ euklDistance(p_1,p_2) = \sqrt{(p_2.x - p_1.x)^2 + (p_2.y - p_1.y)^2 + (p_2.z - p_1.z)^2} \]
Der Unterschied zur vorhergehenden Funktion besteht darin, dass zwei Vektor3D-Objekte übergeben werden und die Abfrage auf Überlauf um die z-Koordinaten erweitert wurde.\\
\\
\textbf{manhattanDistance() mit zwei übergebenen Vektor2D-Objekten:} Die Manhattan-Distanz für zwei 2D-Vektoren bezeichnet die Distanz zwischen diesen als die Summe der absoluten Differenzen ihrer Einzelkoordinaten. Die Funktion wurde auf Basis von folgender mathematischen Formel programmiert:
\[ manhattanDistance(p_1,p_2) = | p_2.x - p_1.x | + | p_2.y - p_1.y | \]
Dabei war darauf zu achten, dass die Differenz der beiden Vektorkoordinaten im Betrag auf vermeintlichen Überlauf geprüft wird und dies im Fehlerfall mit einer Exception behandelt wird.
\begin{lstlisting}
	public static double manhattanDistance(Vektor2D a, Vektor2D b) throws Exception
	{
		if((Math.abs(b.x-a.x)>=Double.MAX_VALUE) || (Math.abs(b.y-a.y)>=Double.MAX_VALUE) || ((Math.abs(b.x-a.x)+Math.abs(b.y-a.y))>=Double.MAX_VALUE))
			throw new Exception("Ueberlauf! Bitte den maximalen Wertebereich beachten!");
		return (Math.abs(b.x-a.x)+ Math.abs(b.y-a.y));
	}
\end{lstlisting} $\;$ \\
\\
\textbf{manhattanDistance() mit zwei übergebenen Vektor3D-Objekten:} Die Manhattan-Distanz für zwei 3D-Vektoren bezeichnet die Distanz zwischen diesen als die Summe der absoluten Differenzen ihrer Einzelkoordinaten. Die Funktion wurde auf Basis von folgender mathematischen Formel programmiert:
\[ manhattanDistance(p_1,p_2) = | p_2.x - p_1.x | + | p_2.y - p_1.y | + | p_2.z - p_1.z |\]
Der Unterschied zur vorhergehenden Funktion besteht darin, dass zwei Vektor3D-Objekte übergeben werden und die Abfrage auf Überlauf um die z-Koordinaten erweitert wurde.\\
\\
\textbf{crossProduct() mit zwei übergebenen Vektor2D-Objekten:} Das Kreuzprodukt 
\begin{lstlisting}
	public static double crossProduct(Vektor2D a, Vektor2D b) throws Exception
	{
		if((a.x*b.y)>=Double.MAX_VALUE)
			throw new Exception("Ueberlauf! Bitte den maximalen Wertebereich beachten!");
		return ((a.x*b.y)-(b.x*a.y));
	}
\end{lstlisting} $\;$ \\
Skalarprodukt für 2D-Vektoren:
\[ \vec u \cdot \vec v = u_1 \cdot v_1 + u_2 \cdot v_2\]

Skalarprodukt für 3D-Vektoren:
\[ \vec u \cdot \vec v = u_1 \cdot v_1 + u_2 \cdot v_2 + u_3 \cdot v_3\]

Kreuzprodukt/Determinante für 2D-Vektoren:
\[ \vec u \times \vec v = \begin{pmatrix}
u_1v_2 - u_2v_1
\end{pmatrix}\]

Kreuzprodukt für 3D-Vektoren:
\[ \vec u \times \vec v = \begin{pmatrix}
u_2v_3 - u_3v_2\\
u_3v_3 - u_1v_3\\
u_1v_2 - u_2v_1
\end{pmatrix}\]

Kosinusformel für 2D-/3D-Vektoren:
\[ \cos \alpha = \frac{\vec u \cdot \vec v}{| \vec  u | \cdot | \vec  v | } \]

Sinusformel für 2D-/3D-Vektoren:
\[ \sin \alpha = \frac{ | \vec u \times \vec v | }{| \vec  u | \cdot | \vec  v | } \]

Regel von Sarrus für Determinante von 3x3-Matrizen:
\[ det(A) = u_{11}u_{22}u_{33} + u_{12}u_{23}u_{31} + u_{13}u_{21}u_{32} - u_{13}u_{22}u_{31} - u_{11}u_{23}u_{32} - u_{12}u_{21}u_{33} \]

Bogenmaß zu Gradmaß:
\[ deg = \frac{rad}{\pi} \cdot 180 \]

Gradmaß zu Bogenmaß:
\[ rad = \frac{deg}{180} \cdot \pi \]
\section{Testverfahren}
Für die testgetriebene Entwicklung wurde JUnit verwendet. Bei den Tests haben wir vor allem auf Überlauf getestet, da dies bei den meisten der Methoden eine mögliche Fehlerquelle darstellt. Dazu wurden Rechnungen mit dem maximalen und minimalen Zahlenwerten des Typs Double durchgeführt, um sicher zu stellen, dass die Methoden mit Überlauf korrekt umgeht. 
\\
Bei der Überprüfung auf Korrektheit der Rechnungen wurde mit verschiedenen Zahlenwerten im Doublebereich gearbeitet um zu gewährleisten, dass die Methoden mit verschiedenen Werten fehlerfrei arbeiten. 


\end{document}